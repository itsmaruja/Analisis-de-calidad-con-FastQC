---
---
title: "Fastq QC"
output: html_document
date: "2023-08-24"       
---
```{r, include = FALSE}
##Como no quieroque se vea
## Instalación y carga de paquetes:

#Instalación y carga de paquetes:
#>>>>>>> 2508912dbc7f3635c5ff28f7e9b9874b92c27ffd
```



```{r, include = FALSE}
if (!require("BiocManager", quietly = TRUE))
  install.packages("BiocManager")

if (!require("FastqCleaner", quietly = TRUE))
  BiocManager::install("FastqCleaner")

if (!require("Rqc", quietly = TRUE))
  BiocManager::install("Rqc")

if (!require("ShortRead", quietly = TRUE))
  BiocManager::install("ShortRead")

library(ShortRead)
library(FastqCleaner)
library(Rqc)
```


```{r, include = FALSE}
###COSAS DE NACHO
## Tutoriales de referencia: 

#https://www.bioconductor.org/packages/devel/bioc/vignettes/Rqc/inst/doc/Rqc.html

#http://bioconductor.org/packages/devel/bioc/vignettes/ShortRead/inst/doc/Overview.pdf


## Seteo del directorio de trabajo y descarga de archivos fastq:
```


1. Descarga:


```{r, include = FALSE}
### RUTAS DE ACCESO
a="C://Users//valen//OneDrive//Documents//FACU//Año 2//bioinformatica//Analisis-de-calidad-con-FastQC//fastqfiles"

#a="C://Users//user//OneDrive//Escritorio//Bioinfo//tp fastqc//archivos fatsq"

setwd(a)
```


##Porcentages de "GC" de cada fastq

2. Crear el objeto: 

```{r  echo = FALSE, fig.height=5, fig.width=12}
# Establece el directorio de trabajo
setwd("fastqfiles")

# Lista todos los archivos .fastq en el directorio
files <- list.files(pattern = "\\.fastq$", full.names = TRUE)

# Imprime los archivos para verificar
print(files)

# Procesa cada archivo usando rqcQA
rqcResults <- lapply(files, function(file) {
  print(paste("Procesando archivo:", file))
  
  # Ejecuta rqcQA para el archivo actual
  result <- rqcQA(file, pair=c(1,1), workers=1)
  
  # Devuelve el resultado
  return(result)
})

# Graficar resultados para los primeros 3 archivos
rqcCycleGCPlot(rqcResults[1:3])


rqcCycleGCPlot(rqcResults[4:6])


rqcCycleGCPlot(rqcResults[7:8])

rqcCycleGCPlot(rqcResults[9:10])
                       

# Si quieres guardar los resultados, puedes hacerlo en un archivo RData
save(rqcResults, file = "rqcResults.RData")

```

###Solo se ven irregularidades en el Fastq 7, el cual no tiene variación en su porcentaje de Guanina y Citosina entre el ciclo 91 y aproximadamente el 145. 
```{r echo = FALSE, fig.height=5, fig.width=12}

# Ajustar tamaño del gráfico del boxplot
options(repr.plot.width=40, repr.plot.height=40)  # Ajusta el tamaño según sea necesario

# Graficar boxplots
rqcCycleQualityBoxPlot(rqcResults[1:3])
rqcCycleQualityBoxPlot(rqcResults[4:6])
rqcCycleQualityBoxPlot(rqcResults[7:8])
rqcCycleQualityBoxPlot(rqcResults[9:10])
                    
```


```{r, include = FALSE}
#solo printea dos graficos, arreglado arriba
#setwd("fastqfiles")
#setwd(a)

#checkpoint("Rqc", path= a,{
#  files <- c( "f1.fastq", "f2.fastq", "f3.fastq", "f4.fastq", "f5.fastq", "f6.fastq", "f7.fastq", "f8.fastq", "f9.fastq", #"f10.fastq")
#  print(files)
#  rqcResultSet <- rqcQA(files, pair=c(1,1), workers=1)
#}, keep="rqcResultSet")

#chequeos
#summary(rqcResultSet)
#names(rqcResultSet)


#rqcCycleGCPlot(rqcResultSet)
#rqcCycleQualityBoxPlot(rqcResultSet)
```



3. Reporte html: 

```{r, include = FALSE}
#solo printea dos ¿? 
#CREO QUE ES EL DE NACHO NO SE
#reportFile <- rqcReport(rqcResultSet)
#browseURL(reportFile)
```

4. Distribución de archivos de calidad media por lectura

```{r, echo=FALSE}
rqcReadQualityBoxPlot(rqcResults[1:3])
rqcReadQualityBoxPlot(rqcResults[4:6])
rqcReadQualityBoxPlot(rqcResults[7:8])
rqcReadQualityBoxPlot(rqcResults[9:10])
```

5. 


```{r, echo = FALSE}
rqcReadQualityPlot(rqcResults[1:3])
rqcReadQualityPlot(rqcResults[4:6])
rqcReadQualityPlot(rqcResults[7:8])
rqcReadQualityPlot(rqcResults[9:10])
rqcReadQualityPlot(rqcResults)

```

6. 

```{r echo=FALSE, fig.height=12, fig.width=12}
rqcReadFrequencyPlot(rqcResults)
```
7. 

```{r, echo = FALSE}
rqcReadWidthPlot(rqcResults[1:3])
rqcReadWidthPlot(rqcResults[4:6])
rqcReadWidthPlot(rqcResults[7:8])
rqcReadWidthPlot(rqcResults[9:10])
```


9. 

```{r echo = FALSE, fig.height=5, fig.width=10}
rqcCycleGCPlot(rqcResults[1:3])
rqcCycleGCPlot(rqcResults[4:6])
rqcCycleGCPlot(rqcResults[7:8])
rqcCycleGCPlot(rqcResults[9:10])
```

10. 

```{r echo = FALSE, fig.height=12}
rqcCycleQualityPlot(rqcResults[1:5])
rqcCycleQualityPlot(rqcResults[6:10])
```


12. 

```{r, echo = FALSE}
rqcCycleQualityBoxPlot(rqcResults[1:2])
rqcCycleQualityBoxPlot(rqcResults[3:4])
rqcCycleQualityBoxPlot(rqcResults[5:6])
rqcCycleQualityBoxPlot(rqcResults[7:8])
rqcCycleQualityBoxPlot(rqcResults[9:10])
```

13. 

```{r , echo=FALSE}
rqcCycleBaseCallsPlot(rqcResults[1:3])
rqcCycleBaseCallsPlot(rqcResults[4:6])
rqcCycleBaseCallsPlot(rqcResults[7:8])
rqcCycleBaseCallsPlot(rqcResults[9:10])
```

14. Visualización de los nucleótidos

```{r, echo = FALSE}
b = "C:\\Users\\valen\\OneDrive\\Documents\\FACU\\Año 2\\bioinformatica\\Analisis-de-calidad-con-FastQC\\fastqfiles\\f2.fastq"

#b = "C:\\Users\\user\\OneDrive\\Escritorio\\Bioinfo\\tp fastqc\\archivos fatsq\\f2.fastq"

sampler <- readFastq(b)

head(sread(sampler), 3)
```

14. Visualización de la calidad de los nucleótidos

```{r, echo = FALSE}

sampler <- readFastq(b)

head(quality(sampler), 3)
```


15. Codificación de los nucleótidos

```{r, echo = FALSE}
encoding(quality(sampler))
```

16. Cantidad de reads y de nucleótidos

```{r , echo=FALSE}
countFastq(b)
```


16. Tamaño de los reads

```{r , echo=FALSE}
hist(width(sampler))
```

17. Filtrado y trimeo

```{r , echo=FALSE}

countFastq(b)
```

```{r, echo = FALSE}
#calculates, for each read, the sum of the encoded nucleotide probabilities.

hist(alphabetScore(sampler))

```

```{r, echo = FALSE}
# vamos a suponer que queremos quitar los read menores a 4000 de calidad

table(alphabetScore(sampler)<4000)
# tenemos 690 read de muy poca calidad y los vamos a quitar de nuestro 
# fastq

removed=(sampler)[alphabetScore(sampler)<4000]

sampler=(sampler)[alphabetScore(sampler)>4000]

hist(alphabetScore(sampler))
hist(alphabetScore(removed))

length(sampler)
length(removed)

```
CODIGO DE CHAT GPT PARA REEMPLAZAR EL DE ABAJO, TARDA MIL AÑOS EN CORRER PORQUE HACE UNO POR UNO

```{r}
# Cargar la biblioteca ShortRead
library(ShortRead)

# Definir una función para recortar secuencias basadas en calidad
trim_by_quality <- function(reads, quality_threshold = 20, min_len = 50) {
  
  trimmed_reads <- lapply(seq_along(reads), function(i) {
    # Extraer la secuencia y calidad de la lectura individual
    seq <- sread(reads)[[i]]
    qual <- as(quality(reads)[[i]], "numeric")
    
    # Encontrar el índice de la primera base con calidad por debajo del umbral
    low_qual_pos <- which(qual < quality_threshold)
    
    # Si existe una base de baja calidad, recortar la secuencia hasta esa posición
    if (length(low_qual_pos) > 0) {
      cut_pos <- min(low_qual_pos) - 1  # Índice de corte
    } else {
      cut_pos <- length(qual)  # No recortar si no hay bases de baja calidad
    }
    
    # Recortar la secuencia y las calidades
    if (cut_pos >= min_len) {  # Solo mantener secuencias con longitud >= min_len
      return(ShortReadQ(sread = DNAStringSet(seq[1:cut_pos]), 
                        quality = BStringSet(quality(reads)[[i]][1:cut_pos]), 
                        id = id(reads)[i]))
    } else {
      return(NULL)  # Descartar secuencias que sean demasiado cortas
    }
  })
  
  # Filtrar secuencias nulas
  trimmed_reads <- trimmed_reads[!sapply(trimmed_reads, is.null)]
  
  # Combinar las lecturas recortadas en un solo objeto ShortReadQ
  trimmed_reads_combined <- do.call(c, trimmed_reads)
  
  return(trimmed_reads_combined)
}

# Aplicar la función de recorte a las secuencias
fq2 <- trim_by_quality(sampler, quality_threshold = 20, min_len = 50)

# Verificar el número de lecturas después del recorte
num_reads <- length(fq2)
print(paste("Número de lecturas en fq2 después del recorte:", num_reads))

# Generar un histograma de las longitudes de las secuencias recortadas
if (num_reads > 0) {
  hist(width(fq2), main="Histograma de Longitudes de Secuencias", xlab="Longitud de Secuencias", ylab="Frecuencia")
} else {
  print("No hay lecturas en fq2 para crear el histograma.")
}



```


ERROR TRIMEA TODO EL FASTQ

```{r, echo = FALSE}
#trim trailing nucleotides if 1 nucleotides fall below the quality
#encoded by "5". If successive=FALSE, the 5'th failing nucleotide and 
#all subseqent nucleotides are trimmed. If successive=TRUE, failing
#nucleotides must occur successively; the sequence is trimmed from the
#first of the successive failing nucleotides.
length(sampler)
fq2<-trimTails(sampler,1,"1", successive=TRUE)
length(fq2)
hist(width(fq2))

```
```{r}
# vamos a quitar el primer "TTCCA":
#before
head(sread(sampler), 6)

report <- trimLRPatterns(Lpattern = "TTCCA", subject = sampler, max.Rmismatch = 0, ranges = TRUE)

View(as.data.frame(report))

#arreglado
fq4 <- trimLRPatterns(Lpattern = "TTCCA", subject = sampler, max.Rmismatch = 0, ranges = FALSE)
#sin arreglar
#fq4<-trimLRPatterns(Lpattern = "TTCCA", subject = sampler, max.Rmismatch = 0, ranges = TRUE) #TIRABA ERROR


#after
head(sread(fq4), 6)

```




```{r, echo = FALSE}
# vamos a trimear los ultimos 20 pares de bases 
# de todos los reads de sampler: 

seqs <- sread(sampler)
trimmed_seqs <- narrow(seqs, end = width(seqs) - 20)


# creamos un nuevo objeto ShortReadQ con las secuencias trimeadas
trimmed_sampler <- ShortReadQ(
  sread = trimmed_seqs,
  quality = narrow(quality(sampler), end = width(quality(sampler)) - 20),
  id = id(sampler)
)


boxplot(as(quality(trimmed_sampler), "matrix"), outline = FALSE, main="Quality Scores across all reads after trimming",
        xlab="Position in Read", ylab="Quality Score")

boxplot(as(quality(sampler), "matrix"), outline = FALSE, main="Quality Scores across all reads before trimming",
        xlab="Position in Read", ylab="Quality Score")

```




```{r, echo = FALSE}
fq3<-trimEnds(sampler, "A")
fq3
```


```{r , echo=FALSE}
writeFastq(fq2, "filtered_and_trimmedf2.fastq")
```


```{r , echo=FALSE}
c="C:\\Users\\valen\\OneDrive\\Documents\\FACU\\Año 2\\bioinformatica\\Analisis-de-calidad-con-FastQC"
#c = "C:\\Users\\user\\OneDrive\\Escritorio\\Bioinfo\\tp fastqc\\"
# Establece el directorio de trabajo
setwd(c)

# Lista todos los archivos .fastq filtrados en el directorio
files <- list.files(pattern = "filtered_and_trimmedf[0-9]+\\.fastq$", full.names = TRUE)

# Procesa cada archivo usando rqcQA
rqcResultsfiltered <- lapply(files, function(file) {
  print(paste("Procesando archivo:", file))
  
  # Ejecuta rqcQA para el archivo actual
  #result <- rqcQA(file, pair=c(1,1), workers=1)
  
  # Devuelve el resultado
  #return(result)

})


rqcCycleGCPlot(rqcResultsfiltered)
rqcCycleQualityBoxPlot(rqcResultsfiltered)


```
